<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu Voxel 3D - Étape 29 (Portée du Joueur à 7)</title>
    <!-- Chargement de la bibliothèque Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Outil nécessaire pour fusionner les géométries (performance) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <style>
        /* Styles pour que le jeu prenne toute la page */
        body { margin: 0; overflow: hidden; background-color: #70c5ff; }
        canvas { display: block; }
        
        /* Conteneur pour le bouton de démarrage/verrouillage de la souris */
        #uiContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        #startButton {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            box-shadow: 0 4px #2e7d32;
            transition: background-color 0.1s;
        }
        #startButton:hover { background-color: #66bb6a; }
        #startButton:active {
            background-color: #2e7d32;
            box-shadow: 0 2px #1b5e20;
            transform: translateY(2px);
        }
        #instructions {
            margin-top: 15px;
            color: white;
            font-family: sans-serif;
        }
        #fpsIndicator {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 100;
        }

        /* Réticule (Crosshair) */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            margin-top: -4px;
            margin-left: -4px;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 99;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            pointer-events: none; 
        }

        /* Interface de l'inventaire */
        #inventory {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            display: flex;
            gap: 10px;
        }
        .slot {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 3px solid #ccc;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 10px;
            cursor: pointer;
            transition: border-color 0.1s;
            line-height: 1.2;
            text-align: center;
        }
        .slot.selected {
            border-color: gold; /* Indiquer le bloc sélectionné */
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="uiContainer">
        <button id="startButton">Démarrer le Jeu (Cliquez pour verrouiller la souris)</button>
        <div id="instructions">
            S : Avancer | Z : Reculer | Q : Gauche | D : Droite | Espace : Saut<br>
            Clic Gauche : Casser | Clic Droit : Placer
        </div>
    </div>
    <div id="fpsIndicator">FPS: --</div>
    <div id="crosshair"></div>
    
    <!-- Interface d'inventaire -->
    <div id="inventory">
        <div class="slot selected" data-block-type="grass">Herbe (1)</div>
        <div class="slot" data-block-type="dirt">Terre (2)</div>
        <div class="slot" data-block-type="rock">Roche (3)</div>
    </div>

    <script>
        // Variables globales pour le moteur 3D
        let scene, camera, renderer, playerGroup;
        let world = {}; // Stocke les DONNÉES des blocs (position, type)
        const chunkMeshes = {}; // Objets 3D regroupés par type de bloc (performance)
        
        // Raycasting pour l'interaction
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        
        // Inventaire et Blocs
        const inventory = {
            'grass': { count: 999 },
            'dirt': { count: 999 },
            'rock': { count: 999 }
        };
        let selectedBlockType = 'grass'; // Le bloc actuellement sélectionné pour la pose
        
        // --- DÉFINITIONS DE TEXTURES AVEC NOMS DE FICHIERS LOCAUX ---
        const BLOCK_TEXTURES_URL = {
            grass: { url: 'grass.png', top: [0, 1], bottom: [0, 0], side: [1, 1] }, 
            dirt: { url: 'dirt.png', all: [0, 0] },
            rock: { url: 'rock.png', all: [1, 1] }
        };

        const materials = {}; // Contiendra les objets THREE.MeshLambertMaterial (avec maps)
        const textures = {}; // Contiendra les objets THREE.Texture (clé: URL du fichier)

        // Configuration du joueur/caméra
        const PLAYER_HEIGHT = 2.0; 
        const PLAYER_SPEED = 0.12; 
        // Portée maximale définie à 7 unités.
        const MAX_REACH_DISTANCE = 7; 
        
        // Variables de Physique
        let velocityY = 0;
        const GRAVITY = -0.035; 
        const JUMP_POWER = 0.35; 
        let onGround = false; 

        // État des touches pour le mouvement
        const keys = {
            z: false, q: false, s: false, d: false,
            ' ': false, // Espace pour sauter
            '1': false, '2': false, '3': false, 
        };

        // Définition des 6 faces d'un cube et de leurs directions relatives (pour le culling)
        const CUBE_FACES = [
            { dir: [ 0, 0,  1], uv: 4 }, // Front (z+) - Indice 4 de la BoxGeometry
            { dir: [ 0, 0, -1], uv: 5 }, // Back (z-) - Indice 5
            { dir: [ 1, 0,  0], uv: 0 }, // Right (x+) - Indice 0
            { dir: [-1, 0,  0], uv: 1 }, // Left (x-) - Indice 1
            { dir: [ 0, 1,  0], uv: 2 }, // Top (y+) - Indice 2
            { dir: [ 0, -1, 0], uv: 3 }, // Bottom (y-) - Indice 3
        ];
        
        // État du verrouillage du pointeur
        let pointerLocked = false;
        
        // Variables pour le calcul des FPS
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        // --- Fonctions d'Interaction avec le Monde ---
        
        /**
         * Met à jour le monde de données et l'affichage 3D.
         */
        function updateWorld(x, y, z, newType = null) {
            const key = `${x},${y},${z}`;
            
            if (newType) {
                // Placer un bloc
                world[key] = { x, y, z, type: newType };
            } else {
                // Casser un bloc
                delete world[key];
            }

            // Re-fusionner et re-rendre toutes les géométries
            renderMergedChunk();
        }

        /**
         * Gère la destruction d'un bloc.
         */
        function breakBlock(block) {
            if (!block) return;
            
            const { x, y, z, type } = block;
            
            // Simuler l'ajout de la ressource cassée à l'inventaire
            if (inventory[type]) {
                inventory[type].count += 1;
                console.log(`Bloc de ${type} cassé. Vous avez maintenant ${inventory[type].count} ${type}.`);
                updateInventoryUI(); // Mise à jour de l'affichage
            }
            
            updateWorld(x, y, z, null);
        }

        /**
         * Gère la pose d'un bloc (si l'inventaire le permet).
         */
        function placeBlock(x, y, z) {
            const typeToPlace = selectedBlockType;
            if (!typeToPlace || inventory[typeToPlace].count <= 0) {
                console.log("Inventaire vide ou aucun bloc sélectionné.");
                return;
            }

            // 1. Vérifier que l'emplacement n'est pas déjà occupé
            if (isBlockSolid(x, y, z)) {
                 console.log(`IMPOSSIBLE DE PLACER (Occupé): Le bloc à (${x}, ${y}, ${z}) est déjà solide.`);
                 return;
            }

            // 2. Vérifier que le joueur ne se place pas lui-même dans le bloc
            const pX = Math.round(playerGroup.position.x);
            const pZ = Math.round(playerGroup.position.z);
            const pY = playerGroup.position.y;
            
            // Les deux blocs Y occupés par le joueur
            const playerBlockY1 = Math.floor(pY - PLAYER_HEIGHT + 0.1); 
            const playerBlockY2 = Math.floor(pY - PLAYER_HEIGHT + 1.1); 
            
            if (x === pX && z === pZ && (y === playerBlockY1 || y === playerBlockY2)) {
                console.log(`IMPOSSIBLE DE PLACER (Self-Block): Le bloc à (${x}, ${y}, ${z}) est occupé par le joueur.`);
                return;
            }

            // 3. Procéder au placement
            inventory[typeToPlace].count -= 1;
            
            updateWorld(x, y, z, typeToPlace);
            updateInventoryUI(); // Mise à jour de l'affichage
        }

        // --- Fonctions de Génération Procédurale ---

        function getTerrainHeight(x, z) {
            const scale = 0.1; 
            const amplitude = 5; 

            const h1 = Math.sin(x * scale) * amplitude * 0.7;
            const h2 = Math.cos(z * scale * 0.9) * amplitude * 0.8;
            const h3 = Math.sin(x * scale * 0.3 + z * scale * 0.2) * amplitude * 0.5;

            return Math.floor((h1 + h2 + h3) / 2.5);
        }
        
        /**
         * Vérifie si un bloc existe à la position (x, y, z) en regardant dans le 'world' de données.
         */
        function isBlockSolid(x, y, z) {
            // Arrondir les coordonnées d'entrée au cas où elles seraient des flottants 
            const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
            return world.hasOwnProperty(key);
        }

        // --- Fonctions d'Initialisation ---
        
        /**
         * Charge toutes les textures nécessaires pour les blocs.
         * @returns {Promise<void>}
         */
        function loadTextures() {
            const loader = new THREE.TextureLoader();
            const promises = [];
            
            // Collecter les URL uniques de texture à charger
            const uniqueUrls = new Set();
            for (const type in BLOCK_TEXTURES_URL) {
                uniqueUrls.add(BLOCK_TEXTURES_URL[type].url);
            }

            uniqueUrls.forEach(url => {
                if (!textures[url]) {
                    const promise = new Promise((resolve, reject) => {
                        loader.load(
                            url,
                            (texture) => {
                                // Important : Définir le mode de répétition et le filtrage
                                texture.wrapS = THREE.RepeatWrapping;
                                texture.wrapT = THREE.RepeatWrapping;
                                texture.magFilter = THREE.NearestFilter; // Pour un look pixelisé
                                texture.minFilter = THREE.NearestMipmapLinearFilter;
                                textures[url] = texture; // Stocker la texture par son URL
                                resolve();
                            },
                            undefined, // onProgress
                            (error) => {
                                // GESTION D'ERREUR : Utiliser un fallback au lieu de planter
                                console.error(`[ERREUR DE TEXTURE] Impossible de charger la texture : ${url}. VEUILLEZ VÉRIFIER LE NOM DU FICHIER ET SON EMPLACEMENT (il doit être dans le même dossier).`, error);
                                textures[url] = 'error_fallback'; // Marqueur pour indiquer un échec de chargement
                                resolve(); // Résoudre la promesse pour ne pas bloquer Promise.all
                            }
                        );
                    });
                    promises.push(promise);
                }
            });
            return Promise.all(promises);
        }

        function initMaterials() {
            // Matériau de repli (gris) utilisé si une texture locale ne peut pas être chargée
            const fallbackMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc }); 

            // Créer un matériau par type de bloc, en utilisant la texture partagée si possible.
            for (const type in BLOCK_TEXTURES_URL) {
                const config = BLOCK_TEXTURES_URL[type];
                const texture = textures[config.url];

                let material;

                // Si le chargement a échoué (marqué par 'error_fallback') ou si la texture est manquante
                if (texture === 'error_fallback' || !texture) {
                    console.warn(`[ATTENTION] Utilisation du matériau de repli pour le type ${type} car la texture '${config.url}' n'a pas pu être chargée.`);
                    material = fallbackMaterial;
                } else {
                    // Créer un matériau Lambert (pour un éclairage réaliste)
                    material = new THREE.MeshLambertMaterial({ map: texture });
                }
                
                materials[type] = material;
            }
        }


        async function init() {
            // 1. Chargement des textures
            await loadTextures();
            
            // 2. Initialisation des matériaux après le chargement des textures
            initMaterials();
            
            // 3. SCÈNE
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x70c5ff); 

            // 4. CAMÉRA et GROUPE DU JOUEUR 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 0; 
            playerGroup = new THREE.Group(); 
            playerGroup.position.set(0, 0, 0); 
            
            playerGroup.add(camera); 
            scene.add(playerGroup);

            // 5. RENDU (RENDERER)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 6. ÉCLAIRAGE
            const ambientLight = new THREE.AmbientLight(0x808080);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 2, 1);
            scene.add(directionalLight);

            // 7. CRÉATION DU MONDE GÉNÉRÉ
            // Taille de la zone de départ réduite à 16x16 (pour simuler des chunks plus petits)
            generateChunk(0, 0, 16); 
            
            // --- CORRECTION DU SPAWN (Assuré depuis l'étape précédente) ---
            // Utiliser la fonction de génération de hauteur au point (0, 0)
            const terrainY = getTerrainHeight(0, 0); 
            // La position des pieds doit être un bloc au-dessus du bloc de terrain (terrainY + 1)
            // La position Y du groupe du joueur est la position des pieds + la hauteur du joueur
            playerGroup.position.y = (terrainY + 1) + PLAYER_HEIGHT; 
            // ---------------------------
            
            // 8. GESTION DES ÉVÉNEMENTS
            setupEventListeners();
            
            // 9. INITIALISATION DE L'INVENTAIRE
            updateInventoryUI();
            
            // Démarrer l'animation
            animate();
        }

        /**
         * Enregistre simplement le bloc dans la structure de données 'world'.
         */
        function createBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            world[key] = { x, y, z, type };
        }

        /**
         * Génère un chunk et affiche les géométries.
         */
        function generateChunk(startX, startZ, size) {
            console.log(`Génération d'un chunk de ${size}x${size}...`);
            const halfSize = size / 2;

            for (let x = startX - halfSize; x < startX + halfSize; x++) {
                for (let z = startZ - halfSize; z < startZ + halfSize; z++) {
                    const height = getTerrainHeight(x, z);
                    
                    createBlock(x, height, z, 'grass');
                    
                    for (let y = height - 1; y >= height - 3; y--) {
                        createBlock(x, y, z, 'dirt');
                    }
                    
                    for (let y = height - 4; y >= -10; y--) { 
                        createBlock(x, y, z, 'rock');
                    }
                }
            }
            
            renderMergedChunk();
            console.log("Monde généré avec", Object.keys(world).length, "blocs de données.");
        }
        
        /**
         * Vérifie si un bloc existe à la position (x, y, z) en regardant dans le 'world' de données.
         */
        function isBlockSolid(x, y, z) {
            // Arrondir les coordonnées d'entrée au cas où elles seraient des flottants 
            const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
            return world.hasOwnProperty(key);
        }

        /**
         * Crée une face (quad) de cube avec des UVs spécifiques et la fusionne dans la géométrie globale.
         * @param {Array<THREE.BufferGeometry>} targetGeometry - La liste des géométries de face à fusionner.
         * @param {number} x, y, z - Coordonnées mondiales du coin inférieur gauche du cube.
         * @param {string} blockType - Type du bloc ('grass', 'dirt', 'rock').
         * @param {number} faceIndex - Indice de la face (0 à 5) selon CUBE_FACES.
         */
        function addFaceIfVisible(targetGeometry, x, y, z, blockType, faceIndex) {
            // Vérifier si le bloc voisin dans la direction de la face est solide
            const face = CUBE_FACES.find(f => f.uv === faceIndex);
            const [dx, dy, dz] = face.dir;
            
            // Si le bloc voisin est solide, cette face est cachée. On l'ignore (culling).
            if (isBlockSolid(x + dx, y + dy, z + dz)) {
                return;
            }

            // Créer une géométrie Plane pour représenter une seule face (2 triangles)
            const planeGeometry = new THREE.PlaneGeometry(1, 1);

            // --- 1. Rotation et Translation pour aligner le plan avec la face ---

            // Déplacer et tourner le plan pour qu'il corresponde à la face spécifiée
            if (faceIndex === 0) { // Right (x+)
                planeGeometry.rotateY(Math.PI / 2);
                planeGeometry.translate(0.5, 0, 0);
            } else if (faceIndex === 1) { // Left (x-)
                planeGeometry.rotateY(-Math.PI / 2);
                planeGeometry.translate(-0.5, 0, 0);
            } else if (faceIndex === 2) { // Top (y+)
                planeGeometry.rotateX(-Math.PI / 2);
                planeGeometry.translate(0, 0.5, 0);
            } else if (faceIndex === 3) { // Bottom (y-)
                planeGeometry.rotateX(Math.PI / 2);
                planeGeometry.translate(0, -0.5, 0);
            } else if (faceIndex === 4) { // Front (z+)
                // Aucune rotation (face par défaut du PlaneGeometry)
                planeGeometry.translate(0, 0, 0.5);
            } else if (faceIndex === 5) { // Back (z-)
                planeGeometry.rotateY(Math.PI);
                planeGeometry.translate(0, 0, -0.5);
            }

            // --- 2. Application des UVs de la texture (vignette) ---
            const config = BLOCK_TEXTURES_URL[blockType];
            let uv_coord;

            if (config.all) {
                uv_coord = config.all;
            } else {
                // Cas complexe comme l'herbe (Top, Bottom, Side)
                if (faceIndex === 2) uv_coord = config.top;
                else if (faceIndex === 3) uv_coord = config.bottom;
                else uv_coord = config.side;
            }

            // Coordonnées de la vignette (0.5 x 0.5)
            const [u, v] = uv_coord;
            const uMin = u * 0.5;
            const vMin = v * 0.5;
            const uMax = uMin + 0.5;
            const vMax = vMin + 0.5;

            const planeUVs = planeGeometry.attributes.uv.array;
            
            // Mise à jour des UVs de la PlaneGeometry pour correspondre à la vignette
            planeUVs[0] = uMin; planeUVs[1] = vMax; // Coin 1
            planeUVs[2] = uMax; planeUVs[3] = vMax; // Coin 2
            planeUVs[4] = uMin; planeUVs[5] = vMin; // Coin 3
            planeUVs[6] = uMax; planeUVs[7] = vMin; // Coin 4
            
            // --- 3. Translation aux coordonnées mondiales ---
            // Décaler la face à la position correcte du bloc
            planeGeometry.translate(x, y + 0.5, z); 

            // Fusionner la géométrie de cette face dans la géométrie cible
            targetGeometry.push(planeGeometry);
        }

        /**
         * Construit les meshes fusionnées à partir des données du monde, AVEC CULLING.
         */
        function renderMergedChunk() {
            // Supprimer les anciens meshes fusionnés s'ils existent
            for (const type in chunkMeshes) {
                scene.remove(chunkMeshes[type]);
            }

            // Groupements des géométries de faces (et non plus de cubes complets)
            const tempFaceGeometries = { 'grass': [], 'dirt': [], 'rock': [] };

            let totalFacesRendered = 0;

            // Parcourir les données du monde
            for (const key in world) {
                const block = world[key];
                const { x, y, z, type } = block;
                
                // Pour chaque face possible du bloc
                for (const face of CUBE_FACES) {
                    // Tenter d'ajouter la face si elle est visible (non occluse par un bloc voisin)
                    const tempGeometriesList = tempFaceGeometries[type];
                    addFaceIfVisible(tempGeometriesList, x, y, z, type, face.uv);

                    // Calcul de faces (optionnel pour debug)
                    if (tempGeometriesList.length > totalFacesRendered) {
                         totalFacesRendered = tempGeometriesList.length;
                    }
                }
            }

            console.log("Nombre total de faces visibles à fusionner :", totalFacesRendered);

            // Fusionner et ajouter à la scène
            const meshesArray = [];
            for (const type in tempFaceGeometries) {
                if (tempFaceGeometries[type].length > 0) {
                    // Fusionner toutes les géométries de ce type
                    const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(tempFaceGeometries[type]);
                    
                    // Recalculer les normales pour que l'éclairage soit correct après la fusion
                    mergedGeometry.computeVertexNormals(); 

                    // Utiliser le matériau texturé (ou le matériau de repli)
                    const mesh = new THREE.Mesh(mergedGeometry, materials[type]);
                    
                    // IMPORTANT: Marquer le mesh fusionné pour le raycasting
                    mesh.isVoxelChunk = true;
                    
                    scene.add(mesh);
                    chunkMeshes[type] = mesh; 
                    meshesArray.push(mesh);
                }
            }
            return meshesArray;
        }

        // --- Logique d'Inventaire et UI ---
        
        /**
         * Met à jour l'affichage des slots d'inventaire.
         */
        function updateInventoryUI() {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(slot => {
                const type = slot.getAttribute('data-block-type');
                const count = inventory[type] ? inventory[type].count : 0;

                // Mettre à jour le texte du slot
                const name = type.charAt(0).toUpperCase() + type.slice(1);
                const numberKey = slot.innerText.match(/\((\d)\)/)[1]; // Récupère (1), (2), (3)
                slot.innerText = `${name} (${numberKey})\n[${count}]`;

                // Mettre à jour la sélection
                slot.classList.toggle('selected', type === selectedBlockType);

                // Ajouter l'écouteur de clic pour la sélection
                slot.onclick = () => {
                    selectedBlockType = type;
                    updateInventoryUI(); 
                };
            });
        }
        
        /**
         * Sélectionne un type de bloc par son index (1, 2, 3...).
         */
        function selectBlockByIndex(index) {
            const slots = document.querySelectorAll('.slot');
            const targetSlot = slots[index - 1]; // Index 1 -> slot 0
            if (targetSlot) {
                selectedBlockType = targetSlot.getAttribute('data-block-type');
                updateInventoryUI();
            }
        }

        // --- Gestion des Contrôles et Événements ---

        function setupEventListeners() {
            const startButton = document.getElementById('startButton');
            startButton.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });

            document.addEventListener('pointerlockchange', () => {
                pointerLocked = document.pointerLockElement === renderer.domElement;
                const uiContainer = document.getElementById('uiContainer');
                const crosshair = document.getElementById('crosshair');

                if (pointerLocked) {
                    uiContainer.style.display = 'none';
                    crosshair.style.display = 'block';
                    document.addEventListener('keydown', onKeyDown, false);
                    document.addEventListener('keyup', onKeyUp, false);
                    document.addEventListener('mousemove', onMouseMove, false);
                    document.addEventListener('mousedown', onMouseDown, false);
                    velocityY = 0; 
                } else {
                    uiContainer.style.display = 'block';
                    crosshair.style.display = 'none';
                    document.removeEventListener('keydown', onKeyDown, false);
                    document.removeEventListener('keyup', onKeyUp, false);
                    document.removeEventListener('mousemove', onMouseMove, false);
                    document.removeEventListener('mousedown', onMouseDown, false);
                }
            }, false);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            
            // Sélection rapide de l'inventaire
            if (key === '1' || key === '2' || key === '3') {
                selectBlockByIndex(parseInt(key));
            }

            // Gestion du saut - SEULEMENT SI LA TOUCHE EST ENFONCÉE ET QUE LE JOUEUR EST AU SOL
            if (key === ' ' && onGround) {
                velocityY = JUMP_POWER;
                onGround = false;
                event.preventDefault(); 
            }

            // Mappage des touches ZQSD
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                event.preventDefault();
            }
        }

        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        }
        
        /**
         * Gère les Clics Gauche (bouton 0) et Droit (bouton 2)
         */
        function onMouseDown(event) {
            if (!pointerLocked) return;
            
            const intersect = getTargetBlock();

            // --- Clic Gauche (0) : Détruire un bloc ---
            if (event.button === 0) {
                if (intersect) {
                    const blockData = getBlockDataFromRaycast(intersect);
                    if (blockData) {
                        breakBlock(blockData);
                    }
                }
            } 
            // --- Clic Droit (2) : Placer un bloc ---
            else if (event.button === 2) {
                event.preventDefault(); // Empêcher le menu contextuel du navigateur

                if (!intersect) {
                    console.log("ÉCHEC PLACEMENT: Le Raycast n'a trouvé AUCUN bloc. Soit trop loin (> MAX_REACH_DISTANCE unités), soit rien n'est en ligne de mire.");
                    return;
                }
                
                const targetBlockCoords = getBlockCoordsFromRaycast(intersect);
                // La face est dans l'espace local de l'objet, on doit la transformer en espace monde
                const normal = intersect.face.normal.clone();
                normal.transformDirection(intersect.object.matrixWorld).normalize();

                const dx = Math.round(normal.x);
                const dy = Math.round(normal.y);
                const dz = Math.round(normal.z);

                const newX = targetBlockCoords.x + dx;
                const newY = targetBlockCoords.y + dy;
                const newZ = targetBlockCoords.z + dz;
                
                placeBlock(newX, newY, newZ);
            }
        }
        
        /**
         * Effectue le raycasting pour trouver le bloc ciblé.
         */
        function getTargetBlock() {
            // Le Raycaster regarde toujours au centre de l'écran (0, 0 en coordonnées normalisées)
            pointer.set(0, 0); 
            raycaster.setFromCamera(pointer, camera);

            // Ne considérer que les meshes marqués comme des chunks de voxels
            const voxelChunks = scene.children.filter(obj => obj.isVoxelChunk);
            
            const intersects = raycaster.intersectObjects(voxelChunks, false);

            if (intersects.length > 0 && intersects[0].distance < MAX_REACH_DISTANCE) {
                return intersects[0];
            }
            return null;
        }

        /**
         * Récupère les coordonnées du bloc (x, y, z) à partir d'un résultat de raycast
         */
        function getBlockCoordsFromRaycast(intersect) {
            // Recule légèrement du point d'intersection vers l'intérieur du bloc 
            const pointInBlock = intersect.point.clone().sub(intersect.face.normal.clone().multiplyScalar(0.001));
            
            // Correction Y: L'indice Y du bloc est Math.floor(pointInBlock.y)
            return {
                x: Math.round(pointInBlock.x), 
                y: Math.floor(pointInBlock.y), 
                z: Math.round(pointInBlock.z) 
            };
        }

        /**
         * Utilise les coordonnées du bloc ciblé pour retrouver les données dans le 'world'
         */
        function getBlockDataFromRaycast(intersect) {
             const coords = getBlockCoordsFromRaycast(intersect);
             const key = `${coords.x},${coords.y},${coords.z}`;
             return world[key];
        }


        // --- Suite du Mouvement et de la Physique ---

        const mouseSensitivity = 0.002; 

        function onMouseMove(event) {
            if (!pointerLocked) return;

            // Rotation autour de l'axe Y (gauche/droite)
            playerGroup.rotation.y -= event.movementX * mouseSensitivity;

            // Rotation de la caméra (haut/bas)
            let pitch = camera.rotation.x - event.movementY * mouseSensitivity;
            // Limiter l'angle de vue
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            camera.rotation.x = pitch;
        }
        
        /**
         * Calcule la hauteur du sol en cherchant UNIQUEMENT les blocs sous les pieds.
         * @returns {number} Coordonnée Y du niveau du sol (juste au-dessus du bloc solide).
         */
        function getCurrentFloorHeight() {
            const pX = Math.round(playerGroup.position.x);
            const pZ = Math.round(playerGroup.position.z);
            
            let floorY = -Infinity;
            
            // Déterminer le bloc Y où se trouvent actuellement les pieds du joueur.
            // On commence la recherche DEPUIS ce niveau vers le bas.
            let startY = Math.floor(playerGroup.position.y - PLAYER_HEIGHT);
            
            // Rechercher le bloc solide le plus haut DANS la colonne (X, Z) sous startY
            for(let y = startY; y >= -10; y--) {
                if (isBlockSolid(pX, y, pZ)) {
                    // Le sol est le niveau Y+1 (un bloc au-dessus du bloc solide trouvé)
                    floorY = y + 1; 
                    break;
                }
            }
            return floorY === -Infinity ? -100 : floorY; // Retourne -100 si rien n'est trouvé
        }

        /**
         * Applique le mouvement et la physique au joueur, incluant la collision horizontale et verticale.
         */
        function updatePlayerMovement() {
            if (!pointerLocked) return;

            // --- 1. Mouvement Horizontal ---
            const forward = new THREE.Vector3();
            playerGroup.getWorldDirection(forward); 
            forward.y = 0; 
            forward.normalize();
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));
            
            const moveVector = new THREE.Vector3(0, 0, 0);

            // Mappage (S: Avancer | Z: Reculer | D: Gauche | Q: Droite)
            if (keys.s) moveVector.addScaledVector(forward, PLAYER_SPEED); 
            if (keys.z) moveVector.addScaledVector(forward, -PLAYER_SPEED); 
            // Q et D inversés par demande:
            if (keys.d) moveVector.addScaledVector(right, -PLAYER_SPEED); // D va à Gauche
            if (keys.q) moveVector.addScaledVector(right, PLAYER_SPEED);  // Q va à Droite
            
            // Coordonnées actuelles et cible
            const currentX = playerGroup.position.x;
            const currentZ = playerGroup.position.z;
            const pY = playerGroup.position.y;
            
            // Déterminer les deux blocs Y occupés par le joueur (tête et corps)
            const blockY1 = Math.floor(pY - PLAYER_HEIGHT + 0.1); 
            const blockY2 = Math.floor(pY - PLAYER_HEIGHT + 1.1); 

            // --- Collision en X ---
            const targetX = currentX + moveVector.x;
            const targetBlockX = Math.round(targetX);
            const currentBlockZ = Math.round(currentZ);

            let collisionX = false;
            if (isBlockSolid(targetBlockX, blockY1, currentBlockZ) || isBlockSolid(targetBlockX, blockY2, currentBlockZ)) {
                if (Math.abs(moveVector.x) > 0.001 && targetBlockX !== Math.round(currentX)) {
                    collisionX = true;
                }
            }

            // --- Collision en Z ---
            const targetZ = currentZ + moveVector.z;
            const targetBlockZ = Math.round(targetZ);
            const currentBlockX = Math.round(currentX);

            let collisionZ = false;
            if (isBlockSolid(currentBlockX, blockY1, targetBlockZ) || isBlockSolid(currentBlockX, blockY2, targetBlockZ)) {
                if (Math.abs(moveVector.z) > 0.001 && targetBlockZ !== Math.round(currentZ)) {
                    collisionZ = true;
                }
            }

            // Appliquer le mouvement horizontal
            if (!collisionX) {
                playerGroup.position.x = targetX;
            }
            if (!collisionZ) {
                playerGroup.position.z = targetZ;
            }


            // --- 2. Mouvement Vertical (Gravité, Saut et Collisions) ---
            
            velocityY += GRAVITY;
            playerGroup.position.y += velocityY;

            // Mettre à jour les blocs Y après le mouvement vertical
            const newPY = playerGroup.position.y;
            const pX = Math.round(playerGroup.position.x);
            const pZ = Math.round(playerGroup.position.z);
            const newBlockY2 = Math.floor(newPY - PLAYER_HEIGHT + 1.1); // Le bloc occupé par la tête

            // A. Collision avec le Plafond (Ceiling) - Ne vérifie que si on monte (velocityY > 0)
            if (velocityY > 0) { 
                if (isBlockSolid(pX, newBlockY2, pZ)) {
                    // La tête frappe le bloc
                    
                    // Positionner le joueur juste sous le bloc frappé
                    playerGroup.position.y = (newBlockY2 + 1.0) - 0.001; // Niveau du haut du bloc, moins une petite marge
                    
                    velocityY = 0; // Arrêter la montée
                }
            }

            // B. Collision avec le Sol (Floor)
            const floorHeight = getCurrentFloorHeight();
            const playerFeetY = playerGroup.position.y - PLAYER_HEIGHT; 

            if (playerFeetY < floorHeight) {
                // Remettre le joueur juste au-dessus du sol (VRAI SOL)
                playerGroup.position.y = floorHeight + PLAYER_HEIGHT;
                velocityY = 0;
                onGround = true; 
            } else if (velocityY < 0) { 
                // Si le joueur est en train de tomber, il n'est plus au sol.
                onGround = false;
            }
        }
        
        // --- Calcul des FPS ---
        function updateFPS(now) {
            frameCount++;
            const delta = now - lastTime;
            if (delta >= 1000) {
                fps = (frameCount * 1000) / delta;
                document.getElementById('fpsIndicator').innerText = `FPS: ${Math.round(fps)}`;
                frameCount = 0;
                lastTime = now;
            }
        }


        // --- Boucle d'Animation (Game Loop) ---

        function animate(now) {
            requestAnimationFrame(animate);
            
            updatePlayerMovement(); 
            updateFPS(now); 

            renderer.render(scene, camera);
        }

        // Démarrage de l'application au chargement de la fenêtre
        window.onload = init;

    </script>
</body>
</html>
